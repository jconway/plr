<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN">
<book>
 <title>PL/R User's Guide - R Procedural Language</title>
 <bookinfo>
  <copyright>
   <year>2003-2009</year>
   <holder>Joseph E Conway</holder>
  </copyright>
 </bookinfo>

 <chapter id="plr-overview">
   <title>Overview</title>

   <para>
    PL/R is a loadable procedural language that enables you to write
    PostgreSQL functions and triggers in the
    <ulink url="http://www.r-project.org/">R programming language</ulink>.
    PL/R offers most (if not all) of the capabilities a function writer has
    in the R language.
   </para>

   <para>
    Commands are available to access the database via the PostgreSQL Server 
    Programming Interface (SPI) and to raise messages via <function>elog()
    </function>. There is no way to access internals of the database backend.
    However the user is able to gain OS-level access under the permissions of
    the PostgreSQL user ID, as with a C function. Thus, any unprivileged
    database user should not be permitted to use this language. It 
    <emphasis>must be installed as an untrusted procedural language</emphasis>
    so that only database superusers can create functions in it. The writer of
    a <application>PL/R</application> function must take care that the function
    cannot be used to do anything unwanted, since it will be able to do
    anything that could be done by a user logged in as the database
    administrator.
   </para>

   <para>
    An implementation restriction is that PL/R procedures cannot be used to
    create input/output functions for new data types.
   </para>

 </chapter>

 <chapter id="plr-install">
  <title>Installation</title>
  <para>
   Place source tar file in <literal>contrib</literal> in the PostgreSQL source
   tree and untar it. The shared object for the R call handler is built and
   installed in the PostgreSQL library directory via the following commands
   (starting from <literal>/path/to/postgresql_source/contrib</literal>):
   <programlisting>
    cd plr
    make
    make install
   </programlisting>
  </para>

  <para>
   As of PostgreSQL 8.0.0, PL/R can also be built without the PostgreSQL source
   tree. Untar PL/R whereever you prefer. The shared object for the R call handler
   is built and installed in the PostgreSQL library directory via the following
   commands (starting from <literal>/path/to/plr</literal>):
   <programlisting>
    cd plr
    USE_PGXS=1 make
    USE_PGXS=1 make install
   </programlisting>
  </para>

  <para>
   Win32 - adjust paths according to your own setup, and be sure to restart
   the PostgreSQL service after changing:
   <programlisting>
    In Windows environment:
    R_HOME=C:\Progra~1\R\R-2.5.0
    Path=%PATH%;C:\Progra~1\R\R-2.5.0\bin

    In MSYS:
    export R_HOME=/c/progra~1/R/R-2.5.0
    export PATH=$PATH:/c/progra~1/PostgreSQL/8.2/bin
    USE_PGXS=1 make
    USE_PGXS=1 make install
   </programlisting>
  </para>

  <para>
   You can use <literal>plr.sql</literal> (which is created in
   <literal>contrib/plr</literal>) to create the language and support
   functions in your database of choice:
   <programlisting>
    psql mydatabase < plr.sql
   </programlisting>
   Alternatively you can create the language manually using SQL commands:
   <programlisting>
CREATE FUNCTION plr_call_handler()
RETURNS LANGUAGE_HANDLER
AS '$libdir/plr' LANGUAGE C;

CREATE LANGUAGE plr HANDLER plr_call_handler;
   </programlisting>
  </para>

  <tip>
   <para>
    If a language is installed into <literal>template1</literal>, all
    subsequently created databases will have the language installed
    automatically.
   </para>
  </tip>

  <tip>
   <para>
    In addition to the documentation, the <literal>plr.out.*</literal> files
    in <literal>plr/expected</literal> are a good source of usage examples.
   </para>
  </tip>

  <tip>
   <para>
    R headers are required. Download and install R prior to building PL/R.
    R must have been built with the <literal>--enable-R-shlib</literal> option
    when it was configured, in order for the libR shared object library to be
    available.
   </para>
  </tip>

  <tip>
   <para>
    Additionally, libR must be findable by your runtime linker.
    On Linux, this involves adding an entry in /etc/ld.so.conf for the
    location of libR (typically $R_HOME/bin or $R_HOME/lib), and then
    running ldconfig. Refer to <literal>man ldconfig</literal> or its
    equivalent for your system.
   </para>
  </tip>

  <tip>
   <para>
    R_HOME must be defined in the environment of the user under which
    PostgreSQL is started, <emphasis>before</emphasis> the postmaster
    is started. Otherwise PL/R will refuse to load. See plr_environ(),
    which allows examination of the environment available to the
    PostgreSQL postmaster process.
   </para>
  </tip>

 </chapter>

 <chapter id="plr-funcs">
   <title>Functions and Arguments</title>

   <para>
    To create a function in the <application>PL/R</> language, use standard R
    syntax, but without the enclosing braces or function assignment.
    Instead of <literal>myfunc <- function(arguments) { function body }</literal>,
    the body of your PL/R function is just <literal>function body</literal>

    <programlisting>
CREATE OR REPLACE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable> AS '
    function body
' LANGUAGE 'plr';
    </programlisting>
   </para>

   <para>
    The body of the function is simply a piece of R script. When the function
    is called, the argument values are passed as variables <literal>
    arg1</literal> ... <literal>argN</literal> to the R script.  The result
    is returned from the R code in the usual way. For example, a function
    returning the greater of two integer values could be defined as:

    <programlisting>
CREATE OR REPLACE FUNCTION r_max (integer, integer) RETURNS integer AS '
    if (arg1 > arg2)
       return(arg1)
    else
       return(arg2)
' LANGUAGE 'plr' STRICT;
    </programlisting>

    Starting with PostgreSQL 8.0, arguments may be explicitly named when
    creating a function. If an argument is explicitly named at function
    creation time, that name will be available to your R script in place
    of the usual <literal>argN</literal> variable. For example:

    <programlisting>
CREATE OR REPLACE FUNCTION sd(vals float8[]) RETURNS float AS '
    sd(vals)
' LANGUAGE 'plr' STRICT;
    </programlisting>

    Note the clause <literal>STRICT</>, which saves us from
    having to think about NULL input values: if a NULL is passed, the
    function will not be called at all, but will just return a NULL
    result automatically.
   </para>

   <para>
    In a non-strict function, if the actual value of an argument
    is NULL, the corresponding <literal>argN</literal> variable will be set
    to a <literal>NULL</literal> R object. For example, suppose that we wanted
    <function>r_max</function> with one null and one non-null argument to
    return the non-null argument, rather than NULL:

    <programlisting>
CREATE OR REPLACE FUNCTION r_max (integer, integer) RETURNS integer AS '
    if (is.null(arg1) && is.null(arg2))
        return(NULL)
    if (is.null(arg1))
        return(arg2)
    if (is.null(arg2))
        return(arg1)
    if (arg1 > arg2)
       return(arg1)
    arg2
' LANGUAGE 'plr';
    </programlisting>
   </para>

   <para>
    As shown above, to return a NULL value from a PL/R function, return
    <literal>NULL</literal>.  This can be done whether the function is strict
    or not.
   </para>

   <para>
    Composite-type (tuple) arguments are passed to the procedure as
    R data.frames. The element names of the frame are the attribute
    names of the composite type. If an attribute in the passed row
    has the NULL value, it will appear as an "NA" in the frame. Here is
    an example:

    <programlisting>
CREATE TABLE emp (name text, age int, salary numeric(10,2));
INSERT INTO emp VALUES ('Joe', 41, 250000.00);
INSERT INTO emp VALUES ('Jim', 25, 120000.00);
INSERT INTO emp VALUES ('Jon', 35, 50000.00);
CREATE OR REPLACE FUNCTION overpaid (emp) RETURNS bool AS '
    if (200000 < arg1$salary) {
        return(TRUE)
    }
    if (arg1$age < 30 && 100000 < arg1$salary) {
        return(TRUE)
    }
    return(FALSE)
' LANGUAGE 'plr';
SELECT name, overpaid(emp) FROM emp;
 name | overpaid
------+----------
 Joe  | t
 Jim  | t
 Jon  | f
(3 rows)

    </programlisting>
   </para>

   <para>
    There is also support for returning a composite-type result value:

    <programlisting>
CREATE OR REPLACE FUNCTION get_emps() RETURNS SETOF emp AS '
    names <- c("Joe","Jim","Jon")
    ages <- c(41,25,35)
    salaries <- c(250000,120000,50000)
    df <- data.frame(name = names, age = ages, salary = salaries)
    return(df)
' LANGUAGE 'plr';
select * from get_emps();
 name | age |  salary
------+-----+-----------
 Jim  |  41 | 250000.00
 Joe  |  25 | 120000.00
 Jon  |  35 |  50000.00
(3 rows)

    </programlisting>
   </para>

   <para>
    An alternative method may be used to create a function in PL/R, if
    certain criteria are met. First, the function must be a simple call
    to an existing R function. Second, the function name used for the PL/R
    function must match that of the R function exactly. If these two criteria
    are met, the PL/R function may be defined with no body, and the arguments
    will be passed directly to the R function of the same name. For example:
    <programlisting>
create or replace function sd(_float8) returns float as '' language 'plr';
select round(sd('{1.23,1.31,1.42,1.27}'::_float8)::numeric,8);
   round    
------------
 0.08180261
(1 row)
    </programlisting>
   </para>

   <tip>
    <para>
     Because the function body is passed as an SQL string literal to
     <command>CREATE FUNCTION</command>, you have to escape single
     quotes and backslashes within your R source, typically by
     doubling them.
    </para>
   </tip>

 </chapter>

 <chapter id="plr-data">
   <title>Passing Data Values</title>

   <para>
    The argument values supplied to a PL/R function's script are
    the input arguments converted to a corresponding R form.
    See <xref linkend="plr-args-table">. Scalar PostgreSQL
    values become single element R vectors. One exception to
    this are scalar bytea values. These are first converted to
    R raw type, and then processed by the R unserialize command.
    One-dimensional PostgreSQL arrays are converted to multi-element
    R vectors, two-dimensional PostgreSQL arrays are mapped to R
    matrixes, and three-dimensional PostgreSQL arrays are converted
    to three-dimensional R arrays. Greater than three-dimensional
    arrays are not supported. Composite-types are transformed into
    R data.frames.
   </para>

   <table id="plr-args-table">
    <title>Function Arguments</title>
    <tgroup cols="2">
     <thead>
      <row>
        <entry>PostgreSQL type</entry>
        <entry>R type</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>logical</type></entry>
      </row>

      <row>
       <entry><type>int2</type>, <type>int4</type></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><type>int8</type>, <type>float4</type>, <type>float8</type>,
              <type>cash</type>, <type>numeric</type></entry>
       <entry><type>numeric</type></entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry><type>object</type></entry>
      </row>

      <row>
       <entry>everything else</entry>
       <entry><type>character</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    Conversely, the return values are first coerced to R character, and
    therefore anything that resolves to a string that is acceptable input
    format for the function's declared return type will produce a result.
    Again, there is an exception for scalar bytea return values. In this
    case, the R object being returned is first processed by the R
    serialize command, and then the binary result is directly mapped
    into a PostgreSQL bytea datum. 
    Similar to argument conversion, there is also a mapping between the
    dimensionality of the declared PostgreSQL return type and the type of
    R object. That mapping is shown in 
    <xref linkend="plr-data-results-dims-table">
   </para>

   <table id="plr-data-results-dims-table">
    <title>Function Result Dimensionality</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>PgSQL return type</entry>
       <entry>R type</entry>
       <entry>Result</entry>
       <entry>Example</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>scalar</type></entry>
       <entry><type>array</type>, <type>matrix</type>, <type>vector</type></entry>
       <entry>first column of first row</entry>
       <entry>c(1,2,3) in R returns 1 in PostgreSQL</entry>
      </row>

      <row>
       <entry><type>setof scalar</type></entry>
       <entry><type>1D array</type>, <type>greater than 2D array</type>, <type>vector</type></entry>
       <entry>multi-row, 1 column set</entry>
       <entry>array(1:10) in R returns 10 rows in PostgreSQL</entry>
      </row>

      <row>
       <entry><type>scalar</type></entry>
       <entry><type>data.frame</type></entry>
       <entry>textual representation of the first column's vector</entry>
       <entry>data.frame(c(1,2,3)) in R returns 'c(1, 2, 3)'</entry>
      </row>

      <row>
       <entry><type>setof scalar</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>#columns > 1, error; #columns == 1, multi-row, 1 column set</entry>
       <entry>(as.data.frame(array(1:10,c(2,5))))[,1] in R returns 2 rows of scalar</entry>
      </row>

      <row>
       <entry><type>array</type></entry>
       <entry><type>1D array</type>, <type>greater than 3D array</type>, <type>vector</type></entry>
       <entry>1D array</entry>
       <entry>array(1:8,c(2,2,2,2)) in R returns {1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8}</entry>
      </row>

      <row>
       <entry><type>array</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>2D array</entry>
       <entry>array(1:4,c(2,2)) in R returns {{1,3},{2,4}}</entry>
      </row>

      <row>
       <entry><type>array</type></entry>
       <entry><type>3D array</type></entry>
       <entry>3D array</entry>
       <entry>array(1:8,c(2,2,2)) in R returns {{{1,5},{3,7}},{{2,6},{4,8}}}</entry>
      </row>

      <row>
       <entry><type>composite</type></entry>
       <entry><type>1D array</type>, <type>greater than 2D array</type>, <type>vector</type></entry>
       <entry>first row, 1 column</entry>
       <entry>array(1:8,c(2,2,2)) in R returns 1 row of scalar</entry>
      </row>

      <row>
       <entry><type>setof composite</type></entry>
       <entry><type>1D array</type>, <type>greater than 2D array</type>, <type>vector</type></entry>
       <entry>multi-row, 1 column set</entry>
       <entry>array(1:8,c(2,2,2)) in R returns 8 rows of scalar</entry>
      </row>

      <row>
       <entry><type>composite</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>first row, multi-column</entry>
       <entry>array(1:4,c(2,2)) in R returns 1 row of 2 columns</entry>
      </row>

      <row>
       <entry><type>setof composite</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>multi-row, multi-column set</entry>
       <entry>array(1:4,c(2,2)) in R returns 2 rows of 2 columns</entry>
      </row>

     </tbody>
    </tgroup>
   </table>
 </chapter>

 <chapter id="plr-global-data">
   <title>Using Global Data</title>

   <para>
    Sometimes it is useful to have some global status data that is held
    between two calls to a procedure or is shared between different
    procedures. Equally useful is the ability to create functions that
    your PL/R functions can share. This is easily done since all PL/R
    procedures executed in one backend share the same R interpreter.  So,
    any global R variable is accessible to all PL/R procedure calls, and
    will persist for the duration of the SQL client connection. An example
    of using a global object appears in the
    <function>pg.spi.execp</function> example, in
    <xref linkend="plr-spi-rsupport-funcs">.
   </para>

   <para>
    A globally available, user named, R function (the R function name of PL/R
    functions is not the same as its PostgreSQL function name; see: 
    <xref linkend="plr-func-naming">) can be created dynamically
    using the provided PostgreSQL function 
    <function>install_rcmd(text)</function>. Here is an example:
    <programlisting>
select install_rcmd('pg.test.install <-function(msg) {print(msg)}');
 install_rcmd 
--------------
 OK
(1 row)

create or replace function pg_test_install(text) returns text as '
  pg.test.install(arg1)
' language 'plr';

select pg_test_install('hello world');
 pg_test_install 
-----------------
 hello world
(1 row)
    </programlisting>
   </para>

   <para>
    A globally available, user named, R function can also be automatically
    created and installed in the R interpreter. See: 
    <xref linkend="plr-module-funcs">
   </para>

   <para>
    PL/R also provides a global variable called pg.state.firstpass. This
    variable is reset to TRUE the first time <emphasis>each</emphasis> PL/R
    function is called, for a particular query. On subsequent calls the
    value is left unchanged. This allows one or more PL/R functions to
    perform a possibly expensive initialization on the first call, and
    reuse the results for the remaining rows in the query. For example:
    <programlisting>
create table t (f1 int);
insert into t values (1);
insert into t values (2);
insert into t values (3);

create or replace function f1() returns int as '
  msg <- paste("enter f1, pg.state.firstpass is", pg.state.firstpass)
  pg.thrownotice(msg)
  if (pg.state.firstpass == TRUE)
    pg.state.firstpass &lt;&lt;- FALSE
  msg &lt;- paste("exit f1, pg.state.firstpass is", pg.state.firstpass)
  pg.thrownotice(msg)
  return(0)
' language plr;

create or replace function f2() returns int as '
  msg &lt;- paste("enter f2, pg.state.firstpass is", pg.state.firstpass)
  pg.thrownotice(msg)
  if (pg.state.firstpass == TRUE)
    pg.state.firstpass &lt;&lt;- FALSE
  msg &lt;- paste("exit f2, pg.state.firstpass is", pg.state.firstpass)
  pg.thrownotice(msg)
  return(0)
' language plr;

select f1(), f2(), f1 from t;
NOTICE:  enter f1, pg.state.firstpass is TRUE
NOTICE:  exit f1, pg.state.firstpass is FALSE
NOTICE:  enter f2, pg.state.firstpass is TRUE
NOTICE:  exit f2, pg.state.firstpass is FALSE
NOTICE:  enter f1, pg.state.firstpass is FALSE
NOTICE:  exit f1, pg.state.firstpass is FALSE
NOTICE:  enter f2, pg.state.firstpass is FALSE
NOTICE:  exit f2, pg.state.firstpass is FALSE
NOTICE:  enter f1, pg.state.firstpass is FALSE
NOTICE:  exit f1, pg.state.firstpass is FALSE
NOTICE:  enter f2, pg.state.firstpass is FALSE
NOTICE:  exit f2, pg.state.firstpass is FALSE
 f1 | f2 | f1
----+----+----
  0 |  0 |  1
  0 |  0 |  2
  0 |  0 |  3
(3 rows)

create or replace function row_number() returns int as '
  if (pg.state.firstpass)
  {
    assign("pg.state.firstpass", FALSE, env=.GlobalEnv)
    lclcntr &lt;- 1
  }
  else
    lclcntr &lt;- plrcounter + 1
  assign("plrcounter", lclcntr, env=.GlobalEnv)
  return(lclcntr)
' language 'plr';

SELECT row_number(), f1 from t;
 row_number | f1
------------+----
          1 |  1
          2 |  2
          3 |  3
(3 rows)
    </programlisting>
   </para>

 </chapter>

 <chapter id="plr-spi-rsupport-funcs">
   <title>Database Access and Support Functions</title>

    <para>
     The following commands are available to access the database from
     the body of a PL/R procedure, or in support thereof:
    </para>

  <sect1 id="plr-spi-rsupport-funcs-normal">
   <title>Normal Support</title>

    <variablelist>

     <varlistentry>
      <term><function>pg.spi.exec</function>
           (<type>character</type> <replaceable>query</replaceable>)
      </term>
      <listitem>
       <para>
        Execute an SQL query given as a string.  An error in the query
        causes an error to be raised.  Otherwise, the command's return value
        is the number of rows processed for <command>INSERT</command>, 
        <command>UPDATE</command>, or <command>DELETE</command> statements,
        or zero if the query is a utility statement.  If the query is a
        <command>SELECT</command> statement, the values of the selected columns
        are placed in an R data.frame with the target column names used as
        the frame column names. However, non-numeric columns <emphasis>are
        not</emphasis> converted to factors. If you want all non-numeric
        columns converted to factors, a convenience function <function>
        pg.spi.factor</function> (described below) is provided.
       </para>

       <para>
        If a field of a SELECT result is NULL, the target variable for it
        is set to <quote>NA</quote>. For example:
        <programlisting>
create or replace function test_spi_tup(text) returns setof record as '
  pg.spi.exec(arg1)
' language 'plr';

select * from test_spi_tup('select oid, NULL::text as nullcol,
  typname from pg_type where typname = ''oid'' or typname = ''text''')
  as t(typeid oid, nullcol text, typename name);
 typeid | nullcol | typename
--------+---------+----------
     25 |         | text
     26 |         | oid
(2 rows)
        </programlisting>
        The NULL values were passed to R as <quote>NA</quote>, and on return to
        PostgreSQL they were converted back to NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.prepare</function>
           (<type>character</type> <replaceable>query</replaceable>, 
            <type>integer vector</type> <replaceable>type_vector</replaceable>)
      </term>
      <listitem>
       <para>
        Prepares and saves a query plan for later execution. The saved plan
        will be retained for the life of the current backend.
       </para>

       <para>
        The query may use <firstterm>arguments</firstterm>, which are
        placeholders for values to be supplied whenever the plan is actually
        executed. In the query string, refer to arguments by the symbols
        <literal>$1</literal> ... <literal>$n</literal>. If the query uses
        arguments, the values of the argument types must be given as a vector. 
        Pass <literal>NA</literal> for <replaceable>type_vector</replaceable>
        if the query has no arguments. The argument types must be identified
        by the type Oids, shown in pg_type. Global variables are provided for
        this use. They are named according to the convention TYPENAMEOID, where
        the actual name of the type, in all capitals, is substituted for
        TYPENAME. A support function, <function>load_r_typenames()</function>
        must be used to make the predefined global variables available for use:
        <programlisting>
select load_r_typenames();
 load_r_typenames
------------------
 OK
(1 row)
        </programlisting>
        Another support function, <function>r_typenames()</function> may be
        used to list the predefined Global variables:
        <programlisting>
select * from r_typenames();
    typename     | typeoid
-----------------+---------
 ABSTIMEOID      |     702
 ACLITEMOID      |    1033
 ANYARRAYOID     |    2277
 ANYOID          |    2276
 BITOID          |    1560
 BOOLOID         |      16
  [...]
 TRIGGEROID      |    2279
 UNKNOWNOID      |     705
 VARBITOID       |    1562
 VARCHAROID      |    1043
 VOIDOID         |    2278
 XIDOID          |      28
(59 rows)
        </programlisting>
       </para>

       <para>
        The return value from <function>pg.spi.prepare</function> is a query ID
        to be used in subsequent calls to <function>pg.spi.execp</function>. See
        <function>spi_execp</function> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.execp</function>
           (<type>external pointer</type> <replaceable>saved_plan</replaceable>, 
            <type>variable list</type><replaceable>value_list</replaceable>)
      </term>

      <listitem>
       <para>
        Execute a query previously prepared with <function>pg.spi.prepare
        </function>. <replaceable>saved_plan</replaceable> is the external
        pointer returned by <function>pg.spi.prepare</function>. If the query
        references arguments, a <replaceable>value_list</replaceable> must
        be supplied: this is an R list of actual values for the plan arguments.
        It must be the same length as the argument <replaceable>type_vector
        </replaceable> previously given to <function>pg.spi.prepare</function>.
        Pass <literal>NA</literal> for <replaceable>value_list</replaceable>
        if the query has no arguments. The following illustrates the use of
        <function>pg.spi.prepare</function> and <function>pg.spi.execp</function>
        with and without query arguments:
        <programlisting>
create or replace function test_spi_prep(text) returns text as '
  sp <<- pg.spi.prepare(arg1, c(NAMEOID, NAMEOID));
  print("OK")
' language 'plr';

select test_spi_prep('select oid, typname from pg_type 
  where typname = $1 or typname = $2');
 test_spi_prep 
---------------
 OK
(1 row)

create or replace function test_spi_execp(text, text, text) returns setof record as '
  pg.spi.execp(pg.reval(arg1), list(arg2,arg3))
' language 'plr';

select * from test_spi_execp('sp','oid','text') as t(typeid oid, typename name);
 typeid | typename 
--------+----------
     25 | text
     26 | oid
(2 rows)

create or replace function test_spi_prep(text) returns text as '
  sp <<- pg.spi.prepare(arg1, NA);
  print("OK")
' language 'plr';

select test_spi_prep('select oid, typname from pg_type
  where typname = ''bytea'' or typname = ''text''');
 test_spi_prep
---------------
 OK
(1 row)

create or replace function test_spi_execp(text) returns setof record as '
  pg.spi.execp(pg.reval(arg1), NA)
' language 'plr';

select * from test_spi_execp('sp') as t(typeid oid, typename name);
 typeid | typename
--------+----------
     17 | bytea
     25 | text
(2 rows)

create or replace function test_spi_prep(text) returns text as '
  sp <<- pg.spi.prepare(arg1);
  print("OK")
' language 'plr';

select test_spi_prep('select oid, typname from pg_type
  where typname = ''bytea'' or typname = ''text''');
 test_spi_prep
---------------
 OK
(1 row)

create or replace function test_spi_execp(text) returns setof record as '
  pg.spi.execp(pg.reval(arg1))
' language 'plr';

select * from test_spi_execp('sp') as t(typeid oid, typename name);
 typeid | typename
--------+----------
     17 | bytea
     25 | text
(2 rows)
        </programlisting>
       </para>

       <para>
        NULL arguments should be passed as individual <literal>NA</literal> values
        in <replaceable>value_list</replaceable>.
       </para>

       <para>
        Except for the way in which the query and its arguments are specified,
        <function>pg.spi.execp</function> works just like 
        <function>pg.spi.exec</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>pg.spi.cursor_open</function>(
       <type> character</type> <replaceable>cursor_name</replaceable>,
       <type>external pointer</type> <replaceable>saved_plan</replaceable>,
       <type>variable list</type> <replaceable>value_list</replaceable>)
      </term>
      <listitem>
       <para>
        Opens a cursor identified by cursor_name. The cursor can then be used to scroll through
        the results of a query plan previously prepared by pg.spi.prepare. Any arguments to 
        the plan should be specified in argvalues similar to pg.spi.execp. Only read-only cursors
        are supported at the moment.
        <programlisting>
plan <- pg.spi.prepare('SELECT * FROM pg_class');
cursor_obj <- pg.spi.cursor_open('my_cursor',plan);
        </programlisting>
       </para>
       <para>
        Returns a cursor object that be be passed to <function>pg.spi.cursor_fetch</function>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>pg.spi.cursor_fetch</function>(
       <type>external pointer</type> <replaceable>cursor</replaceable>,
       <type>boolean</type> <replaceable>forward</replaceable>,
       <type>integer</type> <replaceable>rows</replaceable>)
      </term>
      <listitem>
       <para>
        Fetches rows from the cursor object previosuly returned by <function>pg.spi.cursor_open
        </function>. If forward is TRUE then the cursor is moved forward to
        fetch at most the number of rows required by the rows parameter.  If forward is 
        FALSE then the cursor is moved backrwards at most the number of rows specified.
       </para>
       <para>
        rows indicates the maximum number of rows that should be returned.
       </para>
       <para>
        <programlisting>
plan <- pg.spi.prepare('SELECT * FROM pg_class');
cursor_obj <- pg.spi.cursor_open('my_cursor',plan);
data <- pg.spi.cursor_fetch(cursor_obj,TRUE,as.integer(10));
        </programlisting>
       </para>
       <para>
        Returns a data frame containing the results.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>pg.spi.cursor_close</function>(
       <type>external pointer</type><replaceable>cursor</replaceable>)
      </term>
      <listitem>
       <para>
        Closes a cursor previously opened by <function>pg.spi.cursor_open</function>
        <programlisting>
plan <- pg.spi.prepare('SELECT * FROM pg_class');
cursor_obj <- pg.spi.cursor_open('my_cursor',plan);
pg.spi.cursor_close(cursor_obj);
        </programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.lastoid</function>()</term>
      <listitem>
       <para>
        Returns the OID of the row inserted by the last query executed via
        <function>pg.spi.exec</function> or <function>pg.spi.execp</function>,
        if that query was a single-row INSERT.  (If not, you get zero.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.quoteliteral</function>
           (<type>character</type> <replaceable>SQL_string</replaceable>)
      </term>
      <listitem>
       <para>
        Duplicates all occurrences of single quote and backslash characters
        in the given string.  This may be used to safely quote strings
        that are to be inserted into SQL queries given to
        <function>pg.spi.exec</function> or <function>pg.spi.prepare</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.quoteident</function>
           (<type>character</type> <replaceable>SQL_string</replaceable>)
      </term>
      <listitem>
       <para>
        Return the given string suitably quoted to be used as an identifier
        in an SQL query string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled. This may be used to safely quote
        strings that are to be inserted into SQL queries given to
        <function>pg.spi.exec</function> or <function>pg.spi.prepare</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.thrownotice</function>
           (<type>character</type> <replaceable>message</replaceable>)
      </term>
      <term><function>pg.throwerror</function>
           (<type>character</type> <replaceable>message</replaceable>)
      </term>

      <listitem>
       <para>
        Emit a PostgreSQL <literal>NOTICE</literal> or <literal>ERROR</literal>
        message. <literal>ERROR</literal> also raises an error condition:
        further execution of the function is abandoned, and the current
        transaction is aborted.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.factor</function>
           (<type>data.frame</type> <replaceable>data</replaceable>)
      </term>

      <listitem>
       <para>
        Accepts an R <type>data.frame</type> as input, and converts all
        non-numeric columns to <type>factor</type>s. This may be useful
        for data.frames produced by <function>pg.spi.exec</function> or
        <function>pg.spi.prepare</function>, because the PL/R conversion
        mechanism does <emphasis>not</emphasis> do that for you.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </sect1>
  <sect1 id="plr-spi-rsupport-funcs-compat">
   <title>RPostgreSQL Compatibility Support</title>

    <variablelist>
     <varlistentry>
      <listitem>
       <para>
        The following functions are intended to provide some level of compatibility between
        PL/R and RPostgreSQL (PostgreSQL DBI package). This allows, for example, a function
        to be first prototyped using an R client, and then easily moved to PL/R for
        production use.
       </para>
      </listitem>

      <term><function>dbDriver</function>
           (<type>character</type> <replaceable>dvr_name</replaceable>)
      </term>
      <term><function>dbConnect</function>
           (<type>DBIDriver</type> <replaceable>drv</replaceable>,
            <type>character</type> <replaceable>user</replaceable>,
            <type>character</type> <replaceable>password</replaceable>,
            <type>character</type> <replaceable>host</replaceable>,
            <type>character</type> <replaceable>dbname</replaceable>,
            <type>character</type> <replaceable>port</replaceable>,
            <type>character</type> <replaceable>tty</replaceable>,
            <type>character</type> <replaceable>options</replaceable>)
      </term>
      <term><function>dbSendQuery</function>
           (<type>DBIConnection</type> <replaceable>conn</replaceable>,
            <type>character</type> <replaceable>sql</replaceable>)
      </term>
      <term><function>fetch</function>
           (<type>DBIResult</type> <replaceable>rs</replaceable>,
            <type>integer</type> <replaceable>num_rows</replaceable>)
      </term>
      <term><function>dbClearResult</function>
           (<type>DBIResult</type> <replaceable>rs</replaceable>)
      </term>
      <term><function>dbGetQuery</function>
           (<type>DBIConnection</type> <replaceable>conn</replaceable>,
            <type>character</type> <replaceable>sql</replaceable>)
      </term>
      <term><function>dbReadTable</function>
           (<type>DBIConnection</type> <replaceable>conn</replaceable>,
            <type>character</type> <replaceable>name</replaceable>)
      </term>
      <term><function>dbDisconnect</function>
           (<type>DBIConnection</type> <replaceable>conn</replaceable>)
      </term>
      <term><function>dbUnloadDriver</function>
           (<type>DBIDriver</type> <replaceable>drv</replaceable>)
      </term>

      <listitem>
       <para>
        These functions nominally work like their RPostgreSQL counterparts
        except that all queries are performed in the current database.
        Therefore all driver and connection related parameters are
        ignored, and dbDriver, dbConnect, dbDisconnect, and dbUnloadDriver
        are no-ops.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </sect1>
 </chapter>

 <chapter id="plr-pgsql-support-funcs">
   <title>PostgreSQL Support Functions</title>
    <para>
     The following commands are available to use in PostgreSQL queries
     to aid in the use of PL/R functions:
    </para>

    <variablelist>
     <varlistentry>
      <term><function>install_rcmd</function>
           (<type>text</type> <replaceable>R_code</replaceable>)
      </term>
      <listitem>
       <para>
        Install R code, given as a string, into the interpreter. See
        <xref linkend="plr-global-data"> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>reload_plr_modules</function>
           ()
      </term>
      <listitem>
       <para>
        Force re-loading of R code from the <literal>plr_modules</literal>
        table. It is useful after modifying the contents of
        <literal>plr_modules</literal>, so that the change will have an
        immediate effect.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_singleton_array</function>
           (<type>float8</type> <replaceable>first_element</replaceable>)
      </term>
      <listitem>
       <para>
        Creates a new PostgreSQL array, using element 
        <replaceable>first_element</replaceable>. This function is predefined
        to accept one float8 value and return a float8 array. The C function
        that implements this PostgreSQL function is capable of accepting and
        returning other data types, although the return type must be an array
        of the input parameter type. It can also accept multiple input
        parameters. For example, to define a <function>plr_array</function>
        function to create a text array from two input text values:
     <programlisting>
CREATE OR REPLACE FUNCTION plr_array (text, text)
RETURNS text[]
AS '$libdir/plr','plr_array'
LANGUAGE 'C' WITH (isstrict);

select plr_array('hello','world');
   plr_array
---------------
 {hello,world}
(1 row)
     </programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_array_push</function>
           (<type>float8[]</type> <replaceable>array</replaceable>,
            <type>float8</type> <replaceable>next_element</replaceable>)
      </term>
      <listitem>
       <para>
        Pushes a new element onto the end of an existing PostgreSQL array.
        This function is predefined to accept one float8 array and a float8
        value, and return a float8 array. The C function that implements this
        PostgreSQL function is capable of accepting and returning other data
        types. For example, to define a <function>plr_array_push</function>
        function to add a text value to an existing text array:
     <programlisting>
CREATE OR REPLACE FUNCTION plr_array_push (_text, text)
RETURNS text[]
AS '$libdir/plr','plr_array_push'
LANGUAGE 'C' WITH (isstrict);

select plr_array_push(plr_array('hello','world'), 'how are you');
       plr_array_push
-----------------------------
 {hello,world,"how are you"}
(1 row)
     </programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_array_accum</function>
           (<type>float8[]</type> <replaceable>state_value</replaceable>,
            <type>float8</type> <replaceable>next_element</replaceable>)
      </term>
      <listitem>
       <para>
        Creates a new array using <replaceable>next_element</replaceable> if
        <replaceable>state_value</replaceable> is NULL. Otherwise, pushes
        <replaceable>next_element</replaceable> onto the end of
        <replaceable>state_value</replaceable>. This function is predefined
        to accept one float8 array and a float8 value, and return a float8
        array. The C function that implements this PostgreSQL function is
        capable of accepting and returning other data types. For example,
        to define a <function>plr_array_accum</function> function to add an
        int4 value to an existing int4 array:
        <programlisting>
CREATE OR REPLACE FUNCTION plr_array_accum (_int4, int4)
RETURNS int4[]
AS '$libdir/plr','plr_array_accum'
LANGUAGE 'C';

select plr_array_accum(NULL, 42);
 plr_array_accum
-------------
 {42}
(1 row)
select plr_array_accum('{23,35}', 42);
 plr_array_accum
-----------------
 {23,35,42}
(1 row)
        </programlisting>
        This function may be useful for creating custom aggregates. See
        <xref linkend="plr-aggregate-funcs"> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>load_r_typenames</function>()</term>
      <listitem>
       <para>
        Installs datatype Oid variables into the R interpreter
        as globals. See also <function>r_typenames</function> below.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>r_typenames</function>()</term>
      <listitem>
       <para>
        Displays the datatype Oid variables installed into the R interpreter
        as globals. See <xref linkend="plr-spi-rsupport-funcs"> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_environ</function>()</term>
      <listitem>
       <para>
        Displays the environment under which the Postmaster is currently
        running. This may be useful to debug issues related to R specific
        environment variables. This function is installed with EXECUTE
        permission revoked from PUBLIC.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_set_display</function>(<type>text</type> <replaceable>display</replaceable>)</term>
      <listitem>
       <para>
        Sets the DISPLAY environment vaiable under which the Postmaster is currently
        running. This may be useful if using R to plot to a virtual frame buffer.
        This function is installed with EXECUTE permission revoked from PUBLIC.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>plr_get_raw</function>(<type>bytea</type> <replaceable>serialized_object</replaceable>)</term>
      <listitem>
       <para>
        By default, when R objects are returned as type <type>bytea</type>, the
        R object is serialized using an internal R function prior to sending to PostgreSQL.
        This function unserializes the R object using another internal R function, and
        returns the pure raw bytes to PostgreSQL. This is useful, for example, if the R
        object being returned is a JPEG or PNG graphic for use outside of R.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </chapter>

 <chapter id="plr-aggregate-funcs">
   <title>Aggregate Functions</title>
    <para>
     Aggregates in PostgreSQL are extensible via SQL commands. In
     general, to create a new aggregate, a state transition function and
     possibly a final function are specified. The final function is used in
     case the desired output of the aggregate is different from the data that
     needs to be kept in the running state value.
    </para>

    <para>
     There is more than one way to create a new aggregate using PL/R. A simple
     aggregate can be defined using the predefined PostgreSQL C function,
     <function>plr_array_accum</function> (see 
     <xref linkend="plr-pgsql-support-funcs">) as a state transition function,
     and a PL/R function as a finalizer. For example:
     <programlisting>
create or replace function r_median(_float8) returns float as '
  median(arg1)
' language 'plr';

CREATE AGGREGATE median (
  sfunc = plr_array_accum,
  basetype = float8,
  stype = _float8,
  finalfunc = r_median
);

create table foo(f0 int, f1 text, f2 float8);
insert into foo values(1,'cat1',1.21);
insert into foo values(2,'cat1',1.24);
insert into foo values(3,'cat1',1.18);
insert into foo values(4,'cat1',1.26);
insert into foo values(5,'cat1',1.15);
insert into foo values(6,'cat2',1.15);
insert into foo values(7,'cat2',1.26);
insert into foo values(8,'cat2',1.32);
insert into foo values(9,'cat2',1.30);

select f1, median(f2) from foo group by f1 order by f1;
  f1  | median 
------+--------
 cat1 |   1.21
 cat2 |   1.28
(2 rows)
     </programlisting>
    </para>

    <para>
     A more complex aggregate might be created by using a PL/R functions for
     both state transition and finalizer.
    </para>
 </chapter>

 <chapter id="plr-module-funcs">
   <title>Loading R Modules at Startup</title>
    <para>
	 PL/R has support for auto-loading R code during interpreter
     initialization. It uses a special table, <literal>plr_modules</literal>,
     which is presumed to contain modules of R code. If this table exists, the
     modules defined are fetched from the table and loaded into the R
     interpreter immediately after creation.
    </para>

    <para>
     The definition of the table <literal>plr_modules</literal> is as follows:
     <programlisting>
CREATE TABLE plr_modules (
  modseq int4,
  modsrc text
);
     </programlisting>
     The field <literal>modseq</literal> is used to control the order of
     installation. The field <literal>modsrc</literal> contains the full text
     of the R code to be executed, including assignment if that is desired.
     Consider, for example, the following statement:
     <programlisting>
INSERT INTO plr_modules
  VALUES (0, 'pg.test.module.load <-function(msg) {print(msg)}');
     </programlisting>
     This statement will cause an R function named <function>pg.test.module.load
     </function> to be created in the R interpreter on initialization. A PL/R
     function may now simply reference the function directly as follows:
     <programlisting>
create or replace function pg_test_module_load(text) returns text as '
  pg.test.module.load(arg1)
' language 'plr';

select pg_test_module_load('hello world');
 pg_test_module_load 
---------------------
 hello world
(1 row)
     </programlisting>
    </para>

    <para>
     The table <literal>plr_modules</literal> must be readable by all,
     but it is wise to make it owned and writable only by the database
     administrator.
    </para>
 </chapter>

 <chapter id="plr-func-naming">
    <title>R Function Names</title>

    <para>
     In PostgreSQL, one and the same function name can be used for different
     functions as long as the number of arguments or their types differ.
     R, however, requires all function names to be distinct. PL/R deals with
     this by constructing the internal R function names as a concatenation of
     the string <quote>PLR</quote> with the object ID of the procedure's
     <structname>pg_proc</structname>. Thus, PostgreSQL functions with the same
     name and different argument types will be different R functions too. This
     is not normally a concern for a PL/R programmer, but it might be visible
     when debugging.
    </para>

    <para>
     If a specific, known, function name is needed so that an R function can
     be referenced by one or more PL/R functions, the 
     <function>install_rcmd(text)</function> command can be used.
     See <xref linkend="plr-global-data">.
    </para>
 </chapter>

 <chapter id="plr-trigger-func">
   <title>Trigger Procedures</title>

    <indexterm>
     <primary>triggers</primary>
     <secondary>in PL/R</secondary>
    </indexterm>

    <para>
     Trigger procedures can be written in PL/R.
     <productname>PostgreSQL</productname> requires that a procedure that is to be called
     as a trigger must be declared as a function with no arguments
     and a return type of <literal>trigger</>.
    </para>
    <para>
     The information from the trigger manager is passed to the procedure body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><varname>pg.tg.name</varname></term>
       <listitem>
	<para>
	 The name of the trigger from the <command>CREATE TRIGGER</command> statement.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.relid</varname></term>
       <listitem>
	<para>
	 The object ID of the table that caused the trigger procedure
	 to be invoked.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.relname</varname></term>
       <listitem>
	<para>
	 The name of the table that caused the trigger procedure
	 to be invoked.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.when</varname></term>
       <listitem>
	<para>
	 The string <literal>BEFORE</> or <literal>AFTER</> depending on the
	 type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.level</varname></term>
       <listitem>
	<para>
	 The string <literal>ROW</> or <literal>STATEMENT</> depending on the
	 type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.op</varname></term>
       <listitem>
	<para>
	 The string <literal>INSERT</>, <literal>UPDATE</>, or
	 <literal>DELETE</> depending on the type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.new</varname></term>
       <listitem>
	<para>
     When the trigger is defined <command>FOR EACH ROW</>, 
	 a data.frame containing the values of the new table
	 row for <command>INSERT</> or <command>UPDATE</> actions. For
     triggers defined <command>FOR EACH STATEMENT</> and for
     <command>DELETE</> actions, set to <literal>NULL</>.  The
     atribute names are the table's column names.  Columns that are
     null will be represented as NA.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.old</varname></term>
       <listitem>
	<para>
     When the trigger is defined <command>FOR EACH ROW</>, 
	 a data.frame containing the values of the old table
	 row for <command>DELETE</> or <command>UPDATE</> actions. For
     triggers defined <command>FOR EACH STATEMENT</> and for
     <command>INSERT</> actions, set to <literal>NULL</>.  The
     atribute names are the table's column names.  Columns that are
     null will be represented as NA.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>pg.tg.args</varname></term>
       <listitem>
	<para>
	 A vector of the arguments to the procedure as given in the
	 <command>CREATE TRIGGER</command> statement.
	</para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>

    <para>
     The return value from a trigger procedure can be <literal>NULL</> or a
     one row data.frame matching the number and type of columns in the trigger
     table. <literal>NULL</> tells the trigger manager to silently
     suppress the operation for this row. If a one row data.frame is returned,
     it tells PL/R to return a possibly modified row to the trigger manager
     that will be inserted instead of the one given in <varname>pg.tg.new</>.
     This works for <command>INSERT</> and <command>UPDATE</> only. Needless
     to say that all this is only meaningful when the trigger is
     <literal>BEFORE</> and <command>FOR EACH ROW</>; otherwise the return
     value is ignored.
    </para>
    <para>
     Here's a little example trigger procedure that forces an integer value
     in a table to keep track of the number of updates that are performed on the
     row. For new rows inserted, the value is initialized to 0 and then
     incremented on every update operation.

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS '

    if (pg.tg.op == "INSERT")
    {
      retval <- pg.tg.new
      retval[pg.tg.args[1]] <- 0
    }
    if (pg.tg.op == "UPDATE")
    {
      retval <- pg.tg.new
      retval[pg.tg.args[1]] <- pg.tg.old[pg.tg.args[1]] + 1
    }
    if (pg.tg.op == "DELETE")
      retval <- pg.tg.old

    return(retval)
' LANGUAGE plr;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');
</programlisting>

     Notice that the trigger procedure itself does not know the column
     name; that's supplied from the trigger arguments.  This lets the
     trigger procedure be reused with different tables.
    </para>
 </chapter>

 <chapter id="plr-license">
   <title>License</title>

    <para>
     License: GPL version 2 or newer. http://www.gnu.org/copyleft/gpl.html
    </para>

    <para>
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
    </para>

    <para>
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
    </para>

    <para>
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    </para>
 </chapter>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../../doc/src/sgml/reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
